# git mini tutorial


### Создание git-резозитория

Для создания Git-репозитория существуют два основных подхода. 
Первый подход — импорт в Git уже существующего проекта или каталога.
Второй — клонирование уже существующего репозитория с сервера.

codecodecode | description 
---------------- | ---------------
$ git init | Чтобы создать репозиторий в существующем каталоге, то необходимо перейти в проектный каталог и ввести эту команду. На этом этапе ваш проект ещё не находится под версионным контролем. 
$ git clone [url] | Если вы желаете получить копию существующего репозитория Git, например, проекта, в котором вы хотите поучаствовать, то вам нужна  эта команда
$ git clone [url] myfolder | Если вы хотите клонировать репозиторий в каталог, отличный от дефолтной директории, то это указать в следующем параметре командной строки


### Запись изменений в репозиторий

Итак, у вас имеется настоящий Git-репозиторий и рабочая копия файлов для некоторого проекта. Вам нужно делать некоторые изменения и фиксировать “снимки” состояния (snapshots) этих изменений в вашем репозитории каждый раз, когда проект достигает состояния, которое вам хотелось бы сохранить.

Запомните, каждый файл в вашем рабочем каталоге может находиться в одном из двух состояний: под версионным контролем (отслеживаемые) и нет (неотслеживаемые). Отслеживаемые файлы — это те файлы, которые были в последнем слепке состояния проекта (snapshot); они могут быть неизменёнными, изменёнными или подготовленными к коммиту (staged). Неотслеживаемые файлы — это всё остальное, любые файлы в вашем рабочем каталоге, которые не входили в ваш последний слепок состояния и не подготовлены к коммиту. Когда вы впервые клонируете репозиторий, все файлы будут отслеживаемыми и неизменёнными, потому что вы только взяли их из хранилища (checked them out) и ничего пока не редактировали.

Как только вы отредактируете файлы, Git будет рассматривать их как изменённые, т.к. вы изменили их с момента последнего коммита. Вы индексируете (stage) эти изменения и затем фиксируете все индексированные изменения, а затем цикл повторяется. Этот жизненный цикл изображён на рисунке:

![git workflow](https://git-scm.com/figures/18333fig0201-tn.png)

codecodecode | description 
------------------------ | --------------- 
$ git status | Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся
$ git add param| Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда git add. Команда git add принимает параметром путь к файлу или каталогу, если это каталог, команда рекурсивно добавляет (индексирует) все файлы в данном каталоге.
$ git add param | После модификации файла/файлов, их надо проиндексировать чтобы они вошли в следующий коммит.
$ git add . | Сделать все файлы отслеживаемыми, либо сделать все отслеживаемые файлы проиндексироваными
$ git add --all | Сделать все файлы отслеживаемыми, либо сделать все отслеживаемые файлы проиндексироваными (второй вариант)


### Просмотр состояния файлов

codecodecode | description 
---------------- | --------------- 
$ git status | Определяет состояние файлов: отслеживаемые или нет, проиндексированные или нет
$ git diff | Показывает, что изменили, но ещё не проиндексировали И Одновременно что проиндексировали и собираетесь фиксировать. Показывает непосредственно добавленные и удалённые строки — собственно заплатку (patch). 
$ git diff --cached | выводит проиндексированные изменнения, что войдёт в следующий коммит
$ git diff --staged | выводит проиндексированные изменнения, что войдёт в следующий коммит (второй вариант)

### Фиксация изменений
codecodecodecode | description 
---------------- | --------------- 
$ git commit -m "your message here" | фиксация в коммите проиндексированных изменений
$ git commit -a -m "your message here" | добавление параметра -a в команду git commit заставляет Git автоматически индексировать каждый уже отслеживаемый на момент коммита файл, позволяя обойтись без git add

### Удаление/Переименование файлов
codecodecodecode | description 
---------------- | --------------- 
$git rm fileName | Для того чтобы удалить файл из Git'а, вам необходимо удалить его из отслеживаемых файлов (точнее, удалить его из вашего индекса) а затем выполнить коммит. Это позволяет сделать команда git rm, которая также удаляет файл из вашего рабочего каталога, так что вы в следующий раз не увидите его как “неотслеживаемый”.
$ git rm --cached | Удаляет файл из индекса, оставив его при этом в рабочем каталоге. Это особенно полезно, если вы забыли добавить что-то в файл .gitignore и по ошибке проиндексировали, например, большой файл с логами, или кучу промежуточных файлов компиляции.
$ git mv file_from file_to | переименование файла

### Просмотр истории коммитов
codecodecodecode | description 
---------------- | --------------- 
$ git log | Выводит список коммитов созданных в данном репозитории в обратном хронологическом порядке.
$ git -p | -p показывает дельту (diff), привнесенную каждым коммитом.
$ git log -n | Показать последние n коммитов.
$ git stat | Выводит под каждым коммитом список изменённых файлов, количество изменённых файлов, а также количество добавленных и удалённых строк в этих файлах. Он также выводит сводную информацию в конце.
--pretty | Он позволяет изменить формат вывода лога. (oneline, short, full, fuller)
--graph | Параметры oneline и format также полезны с другим параметром команды log — --graph. Этот параметр добавляет миленький ASCII-граф, показывающий историю ветвлений и слияний. 
--name-only | Показывать список изменённых файлов после информации о коммите.
--name-status | Выводить список изменённых файлов вместе с информацией о добавлении/изменении/удалении.
--relative-date | Выводить дату в относительном формате (например, "2 weeks ago") вместо полной даты.
format | Наиболее интересный параметр — это format, который позволяет вам полностью создать собственный формат вывода лога. Например, $ git log --pretty=format:"%h - %an, %ar : %s" 
%H | Хеш коммита
%h | Сокращённый хеш коммита
%P | Хеши родительских коммитов
%p | Сокращённые хеши родительских коммитов
%an | Имя автора
%ar  | 	Дата автора, относительная (пр. "2 мес. назад")
%s | Комментарий
--since, --after | Ограничить коммиты теми, которые сделаны после указанной даты. Такая команда может работать с множеством форматов — точная дата (“2008-01-15”) или относительная дата, такая как “2 years 1 day 3 minutes ago”.
--until, --before | Ограничить коммиты теми, которые сделаны до указанной даты. Ограничить коммиты теми, которые сделаны после указанной даты. Такая команда может работать с множеством форматов — точная дата (“2008-01-15”) или относительная дата, такая как “2 years 1 day 3 minutes ago”.


### Изменение последнего коммита
codecodecodecode | description 
---------------- | --------------- 
$ git commit --amend | Одна из типичных отмен происходит тогда, когда вы делаете коммит слишком рано, забыв добавить какие-то файлы, или напутали с комментарием к коммиту. Если вам хотелось бы сделать этот коммит ещё раз, вы можете выполнить commit с опцией --amend.

### Отмена индексации файла
Допустим, вы внесли изменения в два файла и хотите записать их как два отдельных коммита, но случайно набрали git add * и проиндексировали оба файла. Как теперь отменить индексацию одного из двух файлов? Команда git status напомнит вам об этом.
codecodecodecode | description 
---------------- | --------------- 
$ git reset HEAD [файл] | Исключает файл из индекса


### Отмена изменений файла
Что, если вы поняли, что не хотите оставлять изменения, внесённые в файл benchmarks.rb? Как быстро отменить изменения, вернуть то состояние, в котором он находился во время последнего коммита. git status говорит, как добиться и этого.
codecodecodecode | description 
---------------- | --------------- 
$ git checkout -- <file> 




### Ветвления в git
Ветка в гите - это подвижный указатель на один из коммитов. Ветка master указывает на последнее зафиксированное состояние. 
При каждой следующей фиксации, указатель автоматически смещается вперёд.
